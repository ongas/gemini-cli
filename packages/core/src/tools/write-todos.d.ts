/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import type { ToolInvocation } from './tools.js';
import { BaseDeclarativeTool, type ToolResult } from './tools.js';
export declare const WRITE_TODOS_DESCRIPTION = "This tool helps you manage complex multi-step tasks by creating and tracking a todo list. The list helps you stay organized, avoid missing steps, and shows the user your progress.\n\n## When to AUTOMATICALLY Use This Tool (Proactive Detection)\n\n**IMMEDIATELY create a todo list** when the user request contains these keywords or patterns:\n- \"debug\" / \"fix bug\" / \"troubleshoot\" / \"investigate\"\n- \"failing test\" / \"test fails\" / \"pytest\" / \"test error\"\n- \"implement\" / \"create\" / \"build\" (for features, not simple functions)\n- \"refactor\" (large-scale changes)\n- \"optimize\" / \"improve performance\"\n- \"setup\" / \"configure\" / \"install\"\n- Any task requiring 3+ distinct steps\n\n## Common Task Templates\n\n### For \"Debug failing pytest tests\":\n1. Run pytest to capture the exact failures\n2. Read the failing test file(s)\n3. Understand what behavior is being tested\n4. Identify the root cause in the implementation\n5. Make the necessary fix\n6. Re-run pytest to verify all tests pass\n7. Check for any related tests that might be affected\n\n### For \"Debug X\" or \"Fix bug in Y\":\n1. Reproduce the issue\n2. Identify the root cause\n3. Implement the fix\n4. Verify the fix works\n5. Check for edge cases or regressions\n\n### For \"Implement feature X\":\n1. Understand the requirements\n2. Design the solution approach\n3. Implement core functionality\n4. Add error handling\n5. Write tests\n6. Document the changes\n\n## General Guidelines\n\nUse this tool for complex queries requiring multiple steps. If you find a request is more complex than initially expected, create a todo list immediately.\n\nDO NOT use for simple tasks completable in 1-2 steps or single-turn Q&A.\n\n## Task state definitions\n\n- pending: Work has not begun on a given subtask.\n- in_progress: Marked just prior to beginning work on a given subtask. You should only have one subtask as in_progress at a time.\n- completed: Subtask was succesfully completed with no errors or issues. If the subtask required more steps to complete, update the todo list with the subtasks. All steps should be identified as completed only when they are completed.\n- cancelled: As you update the todo list, some tasks are not required anymore due to the dynamic nature of the task. In this case, mark the subtasks as cancelled.\n\n\n## Methodology for using this tool\n1. Use this todo list list as soon as you receive a user request based on the complexity of the task.\n2. Keep track of every subtask that you update the list with.\n3. Mark a subtask as in_progress before you begin working on it. You should only have one subtask as in_progress at a time.\n4. Update the subtask list as you proceed in executing the task. The subtask list is not static and should reflect your progress and current plans, which may evolve as you acquire new information.\n5. Mark a subtask as completed when you have completed it.\n6. Mark a subtask as cancelled if the subtask is no longer needed.\n7. You must update the todo list as soon as you start, stop or cancel a subtask. Don't batch or wait to update the todo list.\n\n\n## Examples of When to Use the Todo List\n\n<example>\nUser request: Create a website with a React for creating fancy logos using gemini-2.5-flash-image\n\nToDo list created by the agent:\n1. Initialize a new React project environment (e.g., using Vite).\n2. Design and build the core UI components: a text input (prompt field) for the logo description, selection controls for style parameters (if the API supports them), and an image preview area.\n3. Implement state management (e.g., React Context or Zustand) to manage the user's input prompt, the API loading status (pending, success, error), and the resulting image data.\n4. Create an API service module within the React app (using \"fetch\" or \"axios\") to securely format and send the prompt data via an HTTP POST request to the specified \"gemini-2.5-flash-image\" (Gemini model) endpoint.\n5. Implement asynchronous logic to handle the API call: show a loading indicator while the request is pending, retrieve the generated image (e.g., as a URL or base64 string) upon success, and display any errors.\n6. Display the returned \"fancy logo\" from the API response in the preview area component.\n7. Add functionality (e.g., a \"Download\" button) to allow the user to save the generated image file.\n8. Deploy the application to a web server or hosting platform.\n\n<reasoning>\nThe agent used the todo list to break the task into distinct, manageable steps:\n1. Building an entire interactive web application from scratch is a highly complex, multi-stage process involving setup, UI development, logic integration, and deployment.\n2. The agent inferred the core functionality required for a \"logo creator,\" such as UI controls for customization (Task 3) and an export feature (Task 7), which must be tracked as distinct goals.\n3. The agent rightly inferred the requirement of an API service model for interacting with the image model endpoint.\n</reasoning>\n</example>\n\n\n## Examples of When NOT to Use the Todo List\n\n<example>\nUser request: Ensure that the test <test file> passes.\n\nAgent:\n<Goes into a loop of running the test, identifying errors, and updating the code until the test passes.>\n\n<reasoning>\nThe agent did not use the todo list because this task could be completed by a tight loop of execute test->edit->execute test.\n</reasoning>\n</example>\n";
export type TodoStatus = 'pending' | 'in_progress' | 'completed' | 'cancelled';
export interface Todo {
    description: string;
    status: TodoStatus;
}
export interface WriteTodosToolParams {
    /**
     * The full list of todos. This will overwrite any existing list.
     */
    todos: Todo[];
}
export declare class WriteTodosTool extends BaseDeclarativeTool<WriteTodosToolParams, ToolResult> {
    static readonly Name: string;
    constructor();
    protected validateToolParamValues(params: WriteTodosToolParams): string | null;
    protected createInvocation(params: WriteTodosToolParams): ToolInvocation<WriteTodosToolParams, ToolResult>;
}
